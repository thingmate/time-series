export type TimeSeriesTypeEntry<GName extends string, GType> = readonly [name: GName, type: GType];

export type TimeSeriesTypesMap =
  | TimeSeriesTypeEntry<'int64', number>
  | TimeSeriesTypeEntry<'float64', number>
  | TimeSeriesTypeEntry<'text', string>
  | TimeSeriesTypeEntry<'any', any>;

export type TimeSeriesTypeName = TimeSeriesTypesMap[0];

export type InferTimeSeriesType<GTypeName extends TimeSeriesTypeName> = Extract<
  TimeSeriesTypesMap,
  TimeSeriesTypeEntry<GTypeName, any>
>[1];

export interface TimeSeriesEntry<GTypeName extends TimeSeriesTypeName> {
  readonly time: number;
  readonly value: InferTimeSeriesType<GTypeName>;
}

export interface TimeSeriesTimeRangeOptions {
  readonly from?: number;
  readonly to?: number;
}

export interface TimeSeriesSelectOptions extends TimeSeriesTimeRangeOptions {
  readonly from?: number;
  readonly to?: number;
  readonly limit?: number;
  readonly asc?: boolean;
}

export abstract class TimeSeries<GTypeName extends TimeSeriesTypeName> implements Disposable {
  readonly #typeName: GTypeName;

  protected constructor(typeName: GTypeName) {
    this.#typeName = typeName;
  }

  get typeName(): GTypeName {
    return this.#typeName;
  }

  abstract insert(entries: readonly TimeSeriesEntry<TimeSeriesTypeName>[]): void;

  push(time: number, value: InferTimeSeriesType<GTypeName>): void {
    this.insert([{ time, value }]);
  }

  abstract select(options?: TimeSeriesSelectOptions): TimeSeriesEntry<TimeSeriesTypeName>[];

  aggregate(): void {
    // TODO
  }

  abstract drop(): void;

  abstract [Symbol.dispose](): void;
}
