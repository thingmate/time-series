import { DatabaseSync, type StatementSync } from 'node:sqlite';
import {
  TimeSeries,
  type TimeSeriesEntry,
  type TimeSeriesSelectOptions,
  type TimeSeriesTypeName,
} from '../../time-series.ts';

const TIME_SERIES_TYPE_NAME_TO_SQLITE_TYPE_MAP: Record<TimeSeriesTypeName, string> = {
  int64: 'INTEGER',
  float64: 'REAL',
  text: 'TEXT',
  any: 'ANY',
};

type Lines = readonly string[];

function indent(lines: Lines, indent: string = '  '): Lines {
  return lines.map((line: string): string => `${indent}${line}`);
}

export class SqliteTimeSeries<GTypeName extends TimeSeriesTypeName> extends TimeSeries<GTypeName> {
  readonly #db: DatabaseSync;
  readonly #insert: StatementSync;

  constructor(path: string, typeName: GTypeName) {
    super(typeName);
    this.#db = new DatabaseSync(path);

    this.drop();

    this.#db.exec(`
      CREATE TABLE IF NOT EXISTS data(
        time INTEGER NOT NULL PRIMARY KEY,
        value ${TIME_SERIES_TYPE_NAME_TO_SQLITE_TYPE_MAP[this.typeName]} NOT NULL
      ) STRICT, WITHOUT ROWID
    `);

    this.#insert = this.#db.prepare('INSERT INTO data (time, value) VALUES (?, ?)');
  }

  insert(entries: ArrayLike<TimeSeriesEntry<GTypeName>>): void {
    const values: unknown[] = new Array(entries.length * 2);

    const lines: Lines = [
      'INSERT INTO data (time, value)',
      ...indent([
        'VALUES',
        ...indent(
          Array.from({ length: entries.length }, (_, index: number): string => {
            const j: number = index * 2;
            values[j] = entries[index].time;
            values[j + 1] = entries[index].value;
            return `(?, ?)${index === entries.length - 1 ? '' : ','}`;
          }),
        ),
      ]),
    ];

    // console.log(lines.join('\n'));
    const insert: StatementSync = this.#db.prepare(lines.join('\n'));
    insert.run.apply(insert, values);

    // const insert: StatementSync = this.#db.prepare(
    //   [
    //     'BEGIN TRANSACTION;',
    //     Array.from({ length: entries.length }, (): string => {
    //       return 'INSERT INTO data (time, value) VALUES (?, ?);';
    //     }),
    //     'COMMIT;',
    //   ].join('\n'),
    // );
    //
    // const values: unknown[] = new Array(entries.length * 2);
    //
    // for (let i: number = 0, j: number = 0; i < entries.length; i++) {
    //   const { time, value } = entries[i];
    //   values[j++] = time;
    //   values[j++] = value;
    // }
    //
    // // TODO continue here
    // insert.run.apply(insert, values);

    // for (const { time, value } of entries) {
    //   this.#insert.run(time, value);
    // }
  }

  select({
    from = Number.NEGATIVE_INFINITY,
    to = Number.POSITIVE_INFINITY,
    limit = Number.POSITIVE_INFINITY,
    asc = false,
  }: TimeSeriesSelectOptions = {}): TimeSeriesEntry<GTypeName>[] {
    if (
      typeof from !== 'number' ||
      (from !== Number.NEGATIVE_INFINITY && !Number.isSafeInteger(from))
    ) {
      throw new Error('"from" must be an integer in range [-Infinity, +Infinity[.');
    }

    if (
      typeof to !== 'number' ||
      (to !== Number.POSITIVE_INFINITY && !Number.isSafeInteger(to)) ||
      to < from
    ) {
      throw new Error('"to" must be an integer in range [from, +Infinity].');
    }

    if (
      typeof limit !== 'number' ||
      (limit !== Number.POSITIVE_INFINITY && !Number.isSafeInteger(limit)) ||
      limit < 1
    ) {
      throw new Error('"limit" must be an integer in range [1, +Infinity].');
    }

    const lines: Lines = [
      'SELECT *',
      ...indent([
        'FROM data',
        ...((): Lines => {
          const whereLines: Lines = [
            ...(from !== Number.NEGATIVE_INFINITY ? [`time >= ${from}`] : []),
            ...(to !== Number.POSITIVE_INFINITY ? [`time <= ${to}`] : []),
          ];

          return whereLines.length > 0
            ? [
                'WHERE',
                ...indent(
                  whereLines.map((line: string, index: number): string => {
                    return index === 0 ? line : `AND ${line}`;
                  }),
                ),
              ]
            : [];
        })(),
        ...(limit !== Number.POSITIVE_INFINITY ? [`LIMIT ${limit}`] : []),
        `ORDER BY time ${asc ? 'ASC' : 'DESC'}`,
      ]),
    ];

    const query: StatementSync = this.#db.prepare(lines.join('\n'));

    return query.all() as unknown as TimeSeriesEntry<GTypeName>[];
  }

  override drop(): void {
    this.#db.exec(`
      DROP TABLE IF EXISTS data
    `);
  }

  [Symbol.dispose](): void {
    return this.#db[Symbol.dispose]();
  }
}

/*--------*/

// https://github.com/pastgift/sqlstring-sqlite-js/blob/master/lib/SqlString.js#L189
// https://github.com/mysqljs/sqlstring/blob/master/lib/SqlString.js
// var CHARS_GLOBAL_REGEXP = /[']/g;
// var CHARS_ESCAPE_MAP    = {
//   '\'': '\'\'',
// };
//
// function escapeString(val) {
//   var chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
//   var escapedVal = '';
//   var match;
//
//   while ((match = CHARS_GLOBAL_REGEXP.exec(val))) {
//     escapedVal += val.slice(chunkIndex, match.index) + CHARS_ESCAPE_MAP[match[0]];
//     chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
//   }
//
//   if (chunkIndex === 0) {
//     // Nothing was escaped
//     return "'" + val + "'";
//   }
//
//   if (chunkIndex < val.length) {
//     return "'" + escapedVal + val.slice(chunkIndex) + "'";
//   }
//
//   return "'" + escapedVal + "'";
// }
